package ec.gob.inec.presentacion.clases.reportes.spss;

import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.io.UnsupportedEncodingException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.Hashtable;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Vector;

public class SPSSWriterImpl
        implements DataConstants {

    //<editor-fold defaultstate="collapsed" desc="atributos-propiedades">
    public static final Locale DEFAULT_LOCALE = Locale.ENGLISH;
    private static final int RECORD_TYPE_1 = 843859492;
    private static final int RECORD_TYPE_2 = 2;
    private static final int RECORD_TYPE_3 = 3;
    private static final int RECORD_TYPE_4 = 4;
    private static final int RECORD_TYPE_6 = 6;
    private static final int RECORD_TYPE_7 = 7;
    private static final int LONG_VALUE_NAME_SUBTYPE1 = 13;
    private static final int LONG_VALUE_NAME_SUBTYPE2 = 1;
    private static final int EXTENDED_VALUE_LABELS_SUBTYPE = 21;
    private static final int EXTENDED_VALUE_LABELS_DATACODE = 1;
    private static final int EXTENDED_ENCODING_SUBTYPE = 20;
    private static final int EXTENDED_ENCODING_DATACODE = 1;
    private static final int EXTENDED_SPECIFIC_INFO_SUBTYPE = 3;
    private static final int EXTENDED_SPECIFIC_INFO_DATACODE = 4;
    private static final int EXTENDED_SPECIFIC_INFO_COUNT = 8;
    private static final int EXTENDED_SPECIFIC_INFO_RELEASE = 17;
    private static final int EXTENDED_SPECIFIC_INFO_SUBREL = 0;
    private static final int EXTENDED_SPECIFIC_INFO_IDENT = 0;
    private static final int EXTENDED_SPECIFIC_INFO_MACHINE_CODE = 720;
    private static final int EXTENDED_SPECIFIC_INFO_FLOATING = 1;
    private static final int EXTENDED_SPECIFIC_INFO_COMPR_SCHEME = 1;
    private static final int EXTENDED_SPECIFIC_INFO_ENDIAN = 2;
    private static final byte VAR_NUMERIC = 5;
    private static final byte VAR_COMMA = 3;
    private static final byte VAR_DOT = 32;
    private static final byte VAR_DOLLAR = 4;
    private static final byte VAR_STRING = 1;
    private static final byte VAR_DATE01 = 20;
    private static final byte VAR_DATE02 = 21;
    private static final byte VAR_DATE03 = 22;
    private static final byte VAR_DATE04 = 23;
    private static final byte VAR_DATE05 = 24;
    private static final byte VAR_DATE06 = 25;
    private static final byte VAR_DATE07 = 26;
    private static final byte VAR_DATE08 = 27;
    private static final byte VAR_DATE09 = 28;
    private static final byte VAR_DATE10 = 29;
    private static final byte VAR_DATE11 = 30;
    private static final byte VAR_DATE12 = 38;
    protected static final int DEFAULT_COLUMNS = 8;
    protected static final int DEFAULT_ALIGN = 0;
    protected static final int DEFAULT_MEASURE = 1;
    private static final int HEADER_LENGTH = 60;
    private static final String HEADER_START = "@(#) SPSS DATA FILE ";
    public static final String DEFAULT_HEADER = "pmStation spssw  1.84 (demo) 0123456789";
    private static final int FILE_LAYOUT_CODE = 2;
    private static final int NUMBER_OF_VARS = -1;
    private static final int COMPRESSION_SWITCH = 1;
    private static final int CASE_WEIGHT_VAR = 0;
    private static final int NUMBER_OF_CASES = -1;
    private static final double COMPRESSION_BIAS = 100.0D;
    private static final boolean STORE_FORMAT = true;
    public static final int FILE_LABLE_LENGTH = 64;
    public static final String FILE_LABEL = "Generated by Java SPSS Writer v1.84 http://spss.pmStation.com";
    private static final String IGNORED_PADDING = "\000\000\000";
    private static final byte[] FORMAT_SECTION = {7, 0, 0, 0, 11, 0, 0, 0, 4, 0, 0, 0};
    private static final long DATA_SECTION = 999L;
    private boolean closeOutputStream = false;
    private boolean calculateNumberOfCases = true;
    private boolean dictionary;
    private boolean data;
    private boolean directDataWriting = false;
    private OutputStream out;
    private ByteArrayOutputStream headerBuffer;
    String charset;
    private Vector vars;
    private int numberOfVars;
    private int numberOfCases;
    private int compressionSwitch;
    private boolean storeFormat;
    private int currentVar;
    private Hashtable valueLabels = new Hashtable();
    public static final int MAX_BUFFER_LENGTH = 500;
    private SPSSBuffer buffer;
    private OutputStream realOut;
    private ByteArrayOutputStream dataBuffer;
    private int rowCount;
    private Map longStrings = new LinkedHashMap();
    private static final int EXTENDED_LONG_STRINGS = 14;
    private Hashtable baseNums = new Hashtable();
    private Map shift = new HashMap();
    private List complexVls;
    private List complexVlsIndexes;
    private int lastFicNum = 0;
    public static final int COMPRESS_SKIP_CODE = 0;
    public static final int COMPRESS_END_OF_FILE = 252;
    public static final int COMPRESS_NOT_COMPRESSED = 253;
    public static final int COMPRESS_ALL_BLANKS = 254;
    public static final int COMPRESS_MISSING_VALUE = 255;
//</editor-fold>

    //<editor-fold defaultstate="collapsed" desc="constructor">
    protected SPSSWriterImpl() {
    }

    public SPSSWriterImpl(String paramString1, String paramString2)
            throws NullPointerException, IOException {
        this(new File(paramString1), paramString2);
    }

    public SPSSWriterImpl(File paramFile, String paramString)
            throws NullPointerException, IOException {
        this(new FileOutputStream(paramFile), paramString);
    }

    public SPSSWriterImpl(OutputStream paramOutputStream, String paramString)
            throws NullPointerException {
        setOut(paramOutputStream);
        setCharset(paramString);
        this.vars = new Vector();
    }

    public void setCalculateNumberOfCases(boolean paramBoolean) {
        this.calculateNumberOfCases = paramBoolean;
    }
//</editor-fold>

    //<editor-fold defaultstate="collapsed" desc="get and set">
    public OutputStream getOut() {
        return this.out;
    }

    public void setOut(OutputStream paramOutputStream)
            throws NullPointerException {
        if (paramOutputStream == null) {
            throw new NullPointerException();
        }
        headerBuffer = new ByteArrayOutputStream();
        dataBuffer = new ByteArrayOutputStream();
        this.realOut = paramOutputStream;
        this.out = this.headerBuffer;
        this.vars = new Vector();
        this.dictionary = false;
        this.data = false;
    }

    public String getCharset() {
        return this.charset;
    }

    public void setCharset(String paramString) {
        this.charset = paramString;
    }
//</editor-fold>

    //<editor-fold defaultstate="collapsed" desc="mÃ©todos">
    private String equalStrLength(String paramString, int paramInt) {
        String str = paramString;
        if (str == null) {
            str = "";
        }
        if (str.length() > paramInt) {
            str = str.substring(0, paramInt);
        } else {
            for (int i = str.length(); i < paramInt; i++) {
                str = str + " ";
            }
        }
        return str;
    }

    public void addDictionarySection()
            throws IOException {
        addDictionarySection(null, -1, -1, 0, 1, null, null, true);
    }

    public void addDictionarySection(int paramInt)
            throws IOException {
        addDictionarySection(null, -1, paramInt, 0, 1, null, null, true);
    }

    public void addDictionarySection(String paramString1, String paramString2)
            throws IOException {
        addDictionarySection(paramString1, -1, -1, 0, 1, paramString2, null, true);
    }

    public void addDictionarySection(String paramString1, int paramInt1, int paramInt2, String paramString2, boolean paramBoolean)
            throws IOException {
        addDictionarySection(paramString1, paramInt1, paramInt2, 0, 1, paramString2, null, paramBoolean);
    }

    public void addDictionarySection(String paramString1, int paramInt1, int paramInt2, int paramInt3, int paramInt4, String paramString2, Date paramDate, boolean paramBoolean)
            throws IOException {
        paramString1 = "pmStation spssw  1.84 (demo) 0123456789";
        if (paramString2 == null) {
            paramString2 = "Generated by Java SPSS Writer v1.84 http://spss.pmStation.com";
        }
        if (this.calculateNumberOfCases) {
            this.directDataWriting = (paramInt2 != -1);
        } else {
            this.directDataWriting = true;
        }
        if ((this.dictionary) || (this.data)) {
            throw new IOException("wrong data output (dictionary section has been added already)");
        }
        write(843859492);
        write(equalStrLength("@(#) SPSS DATA FILE " + paramString1, 60));
        write(2);
        write(this.numberOfVars = paramInt1);
        write(this.compressionSwitch = paramInt4);
        write(paramInt3);
        write(this.numberOfCases = paramInt2);
        write(100.0D);
        Date localDate = paramDate == null ? new Date() : paramDate;
        SimpleDateFormat localSimpleDateFormat = new SimpleDateFormat("dd MMM yy", DEFAULT_LOCALE);
        write(localSimpleDateFormat.format(localDate));
        localSimpleDateFormat.applyPattern("HH:mm:ss");
        write(localSimpleDateFormat.format(localDate));
        write(equalStrLength(paramString2, 64));
        write("\000\000\000");
        this.out.flush();
        this.storeFormat = paramBoolean;
        this.dictionary = true;
        if (ISettings.IS_LIBRARY_DEMO) {
            addStringVar("demo", 255, "demo");
        }
    }

    public void addNumericVar(String paramString1, int paramInt1, int paramInt2, String paramString2)
            throws IOException {
        addNumericVar(paramString1, paramInt1, paramInt2, paramString2, -1, -1, -1);
    }

    public void addNumericVar(String paramString1, int paramInt1, int paramInt2, String paramString2, MissingValue paramMissingValue)
            throws IOException {
        addNumericVar(paramString1, paramInt1, paramInt2, paramString2, -1, -1, -1, paramMissingValue);
    }

    public void addNumericVar(String paramString1, int paramInt1, int paramInt2, String paramString2, int paramInt3, int paramInt4, int paramInt5)
            throws IOException {
        addVariable(paramString1, 5, paramInt1, paramInt2, paramString2, paramInt3, paramInt4, paramInt5, null);
    }

    public void addNumericVar(String paramString1, int paramInt1, int paramInt2, String paramString2, int paramInt3, int paramInt4, int paramInt5, MissingValue paramMissingValue)
            throws IOException {
        addVariable(paramString1, 5, paramInt1, paramInt2, paramString2, paramInt3, paramInt4, paramInt5, paramMissingValue);
    }

    public void addCommaVar(String paramString1, int paramInt1, int paramInt2, String paramString2)
            throws IOException {
        addCommaVar(paramString1, paramInt1, paramInt2, paramString2, -1, -1, -1);
    }

    public void addCommaVar(String paramString1, int paramInt1, int paramInt2, String paramString2, int paramInt3, int paramInt4, int paramInt5)
            throws IOException {
        addVariable(paramString1, 3, paramInt1, paramInt2, paramString2, paramInt3, paramInt4, paramInt5, null);
    }

    public void addDotVar(String paramString1, int paramInt1, int paramInt2, String paramString2)
            throws IOException {
        addDotVar(paramString1, paramInt1, paramInt2, paramString2, -1, -1, -1);
    }

    public void addDotVar(String paramString1, int paramInt1, int paramInt2, String paramString2, int paramInt3, int paramInt4, int paramInt5)
            throws IOException {
        addVariable(paramString1, 32, paramInt1, paramInt2, paramString2, paramInt3, paramInt4, paramInt5, null);
    }

    public void addDollarVar(String paramString1, int paramInt1, int paramInt2, String paramString2)
            throws IOException {
        addDollarVar(paramString1, paramInt1, paramInt2, paramString2, -1, -1, -1);
    }

    public void addDollarVar(String paramString1, int paramInt1, int paramInt2, String paramString2, int paramInt3, int paramInt4, int paramInt5)
            throws IOException {
        addVariable(paramString1, 4, paramInt1, paramInt2, paramString2, paramInt3, paramInt4, paramInt5, null);
    }

    public void addDollarVar(String paramString1, int paramInt1, int paramInt2, String paramString2, int paramInt3, int paramInt4, int paramInt5, MissingValue paramMissingValue)
            throws IOException {
        addVariable(paramString1, 4, paramInt1, paramInt2, paramString2, paramInt3, paramInt4, paramInt5, paramMissingValue);
    }
    //ik

    public void addStringVar(String paramString1, int paramInt, String paramString2)
            throws IOException {
        addStringVar(paramString1, paramInt, paramString2, -1, -1, -1);
    }

    public void addMultiStringVar(String paramString1, int paramInt, String paramString2)
            throws IOException {
        addMultiStringVar(paramString1, paramInt, paramString2, -1, -1, -1);
    }

    public void addStringVar(String paramString1, int paramInt1, String paramString2, int paramInt2, int paramInt3, int paramInt4)
            throws IOException {
        addStringVar(paramString1, paramInt1, paramString2, paramInt2, paramInt3, paramInt4, null);
    }

    public void addMultiStringVar(String paramString1, int paramInt1, String paramString2, int paramInt2, int paramInt3, int paramInt4)
            throws IOException {
        addMultiStringVar(paramString1, paramInt1, paramString2, paramInt2, paramInt3, paramInt4, null);
    }

    public void addStringVar(String paramString1, int paramInt1, String paramString2, int paramInt2, int paramInt3, int paramInt4, MissingValue paramMissingValue)
            throws IOException {
        if (paramInt1 > 255) {
            addMultiStringVar(paramString1, paramInt1, paramString2, paramInt2, paramInt3, paramInt4, paramMissingValue);
            return;
        }
        addVariable(paramString1, 1, paramInt1, 0, paramString2, paramInt2, paramInt3, paramInt4, paramMissingValue);
    }

    public void addMultiStringVar(String paramString1, int paramInt1, String paramString2, int paramInt2, int paramInt3, int paramInt4, MissingValue paramMissingValue)
            throws IOException {
        int i = paramInt1;
        if (i <= 255) {
            addStringVar(paramString1, paramInt1, paramString2, paramInt2, paramInt3, paramInt4, paramMissingValue);
            return;
        }
        int j = 0;
        Iterator localIterator1 = this.shift.values().iterator();
        while (localIterator1.hasNext()) {
            j += ((Integer) localIterator1.next()) - 1;
        }
        this.shift.put(this.vars.size() - j, countStrings(paramInt1));
        int k = 1;
        ArrayList localArrayList = new ArrayList();
        String str = "";
        int m = 0;
        while (i > 0) {
            if (i >= 252) {
                //mod SPSSVariable
                SPSSVariable localSPSSVariable1 = new SPSSVariable(k != 0 ? paramString1 : fakeName(str, m), 1, 255, 0, paramString2, paramInt2, paramInt3, paramInt4, k != 0 ? paramString1 : fakeName(str, m));
                if (k != 0) {
                    checkVar(localSPSSVariable1);
                    str = localSPSSVariable1.getName().trim();
                    if (str.length() > 5) {
                        str = str.substring(0, 5);
                    }
                    m = getNum(str);
                } else {
                    m++;
                }
                localArrayList.add(localSPSSVariable1);
            } else {
                localArrayList.add(new SPSSVariable(fakeName(str, m), 1, i, 0, paramString2, paramInt2, paramInt3, paramInt4, fakeName(str, m)));
            }
            i -= 252;
            k = 0;
        }
        setNum(str, m + 1);
        SPSSVariable localSPSSVariable1 = (SPSSVariable) localArrayList.get(0);
        this.longStrings.put(localSPSSVariable1.getName(), paramInt1);
        Iterator localIterator2 = localArrayList.iterator();
        k = 1;
        while (localIterator2.hasNext()) {
            SPSSVariable localSPSSVariable2 = (SPSSVariable) localIterator2.next();
            if (k == 0) {
                localSPSSVariable2.setFake(true);
            } else {
                k = 0;
            }
            addVariable(localSPSSVariable2, paramMissingValue);
        }
    }

    private void setNum(String paramString, int paramInt) {
        this.baseNums.put(paramString, paramInt);
    }

    private int getNum(String paramString) {
        Integer localInteger = (Integer) this.baseNums.get(paramString);
        if (localInteger == null) {
            return 0;
        }
        return localInteger;
    }

    public int countStrings(int paramInt) {
        return paramInt / 252 + (paramInt % 252 == 0 ? 0 : 1);
    }

    private String fakeName(String paramString, int paramInt) {
        return paramString + paramInt;
    }

    public void addDateVar(String paramString1, int paramInt, String paramString2)
            throws IOException {
        addDateVar(paramString1, paramInt, paramString2, -1, -1, -1, null);
    }

    public void addDateVar(String paramString1, int paramInt1, String paramString2, int paramInt2, int paramInt3, int paramInt4, MissingValue paramMissingValue)
            throws IOException {
        addVariable(paramString1, getType(paramInt1), getWidth(paramInt1), getDecimals(paramInt1), paramString2, paramInt2, paramInt3, paramInt4, paramMissingValue);
    }

    private int getDecimals(int paramInt) {
        return getMask(0) & paramInt;
    }

    private int getMask(int paramInt) {
        return 255 << paramInt;
    }

    private int getWidth(int paramInt) {
        return (getMask(8) & paramInt) >> 8;
    }

    private int getType(int paramInt) {
        return (getMask(16) & paramInt) >> 16;
    }

    public void addDateVar(String paramString1, String paramString2, String paramString3)
            throws IOException {
        addDateVar(paramString1, paramString2, paramString3, -1, -1, -1, null);
    }

    public void addDateVar(String paramString1, String paramString2, String paramString3, int paramInt1, int paramInt2, int paramInt3, MissingValue paramMissingValue)
            throws IOException {
        int i;
        if (paramString2 != null) {
            switch (paramString2) {
                case "dd-MMM-yyyy":
                    i = 1313536;
                    break;
                case "dd-MMM-yy":
                    i = 1313024;
                    break;
                case "MM/dd/yyyy":
                    i = 1509888;
                    break;
                case "MM/dd/yy":
                    i = 1509376;
                    break;
                case "dd.MM.yyyy":
                    i = 2492928;
                    break;
                case "dd.MM.yy":
                    i = 2492160;
                    break;
                case "yyDDD":
                    i = 1574144;
                    break;
                case "yyyyDDD":
                    i = 1574656;
                    break;
                case "q Q yyyy":
                    i = 1902592;
                    break;
                case "q Q yy":
                    i = 1902080;
                    break;
                case "MMM yyyy":
                    i = 1837056;
                    break;
                case "MMM yy":
                    i = 1836544;
                    break;
                case "ww WK yyyy":
                    i = 1968640;
                    break;
                case "ww WK yy":
                    i = 1968128;
                    break;
                case "dd-MMM-yyyy hh:mm":
                    i = 1446144;
                    break;
                case "dd-MMM-yyyy hh:mm:ss":
                    i = 1446912;
                    break;
                case "dd-MMM-yyyy hh:mm:ss:SS":
                    i = 1447682;
                    break;
                case "hh:mm":
                    i = 1377536;
                    break;
                case "hh:mm:ss":
                    i = 1378304;
                    break;
                case "hh:mm:ss:SS":
                    i = 1379074;
                    break;
                case "DDD hh:mm":
                    i = 1640704;
                    break;
                case "DDD hh:mm:ss":
                    i = 1641472;
                    break;
                case "DDD hh:mm:ss:SS":
                    i = 1642242;
                    break;
                case "EEEEEEEE":
                    i = 1706240;
                    break;
                case "EEE":
                    i = 1704704;
                    break;
                case "MMMMMMMM":
                    i = 1771776;
                    break;
                case "MMM":
                    i = 1770240;
                    break;
                default:
                    i = 1447682;
                    break;
            }
        } else {
            i = 1447682;
        }
        addDateVar(paramString1, i, paramString3, paramInt1, paramInt2, paramInt3, paramMissingValue);
    }

    private void addVariable(String paramString1, int paramInt1, int paramInt2, int paramInt3, String paramString2)
            throws IOException {
        addVariable(paramString1, paramInt1, paramInt2, paramInt3, paramString2, -1, -1, -1, null);
    }

    private void addVariable(String paramString1, int paramInt1, int paramInt2, int paramInt3, String paramString2, int paramInt4, int paramInt5, int paramInt6, MissingValue paramMissingValue)
            throws IOException {
        SPSSVariable localSPSSVariable = new SPSSVariable(paramString1, paramInt1, paramInt2, paramInt3, paramString2, paramInt4, paramInt5, paramInt6, paramString1);
        addVariable(localSPSSVariable, paramMissingValue);
    }

    private void addVariable(SPSSVariable paramSPSSVariable, MissingValue paramMissingValue)
            throws IOException {
        if (!this.dictionary) {
            throw new IOException("wrong data output (dictionary section has not been added)");
        }
        if (this.data) {
            throw new IOException("wrong data output (data section has been added already)");
        }
        if ((this.numberOfVars > 0) && (this.vars.size() >= this.numberOfVars)) {
            throw new IOException("wrong data output (variable count more than available)");
        }
        if ((paramSPSSVariable.getName() == null) || (paramSPSSVariable.getName().length() <= 0)) {
            throw new IOException("wrong data output (variable must have a name)");
        }
        checkVar(paramSPSSVariable);
        write(2);
        write(paramSPSSVariable.getType() == 1 ? paramSPSSVariable.getWidth() : 0);
        if (paramSPSSVariable.isLabeled()) {
            write(1);
        } else {
            write(0);
        }
        if (paramMissingValue != null) {
            write(paramMissingValue.getType());
        } else {
            write(0);
        }
        int i = paramSPSSVariable.getType() << 16 | paramSPSSVariable.getWidth() << 8 | paramSPSSVariable.getDecimals();
        write(i);
        write(i);
        write(paramSPSSVariable.getName());
        if (paramSPSSVariable.isLabeled()) {
            byte[] arrayOfByte = null;
            if (this.charset == null) {
                arrayOfByte = paramSPSSVariable.getLabel().getBytes();
            } else {
                arrayOfByte = paramSPSSVariable.getLabel().getBytes(this.charset);
            }
            int k = arrayOfByte.length;
            write(k);
            if (k % 4 == 0) {
                write(arrayOfByte);
            } else {
                write(equalByteArrLength(arrayOfByte, k + 4 - k % 4));
            }
        }
        writeMissingInformation(paramMissingValue, paramSPSSVariable.getType() == 1);
        for (int j = 8; (paramSPSSVariable.getType() == 1) && (j < paramSPSSVariable.getWidth()); j += 8) {
            write(2);
            write(-1);
            write(0);
            write(0);
            i = paramSPSSVariable.getType() << 16 | paramSPSSVariable.getWidth() << 8 | paramSPSSVariable.getDecimals();
            write(i);
            write(i);
            write("        ");
        }
        this.out.flush();
        this.vars.addElement(paramSPSSVariable);
        //System.out.println("vars " + paramSPSSVariable.getLabel());
    }

    private void writeMissingInformation(MissingValue paramMissingValue, boolean paramBoolean)
            throws IOException {
        if (paramMissingValue == null) {
            return;
        }
        byte[] arrayOfByte = null;
        switch (paramMissingValue.getType()) {
            case 1:
                if (paramBoolean) {
                    arrayOfByte = convert((String) paramMissingValue.getValues()[0]);
                    write(equalByteArrLength(arrayOfByte, 8));
                } else {
                    write((Double) paramMissingValue.getValues()[0]);
                }
                break;
            case -2:
            case 2:
                if (paramBoolean) {
                    arrayOfByte = convert((String) paramMissingValue.getValues()[0]);
                    write(equalByteArrLength(arrayOfByte, 8));
                    arrayOfByte = convert((String) paramMissingValue.getValues()[1]);
                    write(equalByteArrLength(arrayOfByte, 8));
                } else {
                    write((Double) paramMissingValue.getValues()[0]);
                    write((Double) paramMissingValue.getValues()[1]);
                }
                break;
            case -3:
            case 3:
                if (paramBoolean) {
                    arrayOfByte = convert((String) paramMissingValue.getValues()[0]);
                    write(equalByteArrLength(arrayOfByte, 8));
                    arrayOfByte = convert((String) paramMissingValue.getValues()[1]);
                    write(equalByteArrLength(arrayOfByte, 8));
                    arrayOfByte = convert((String) paramMissingValue.getValues()[2]);
                    write(equalByteArrLength(arrayOfByte, 8));
                } else {
                    write((Double) paramMissingValue.getValues()[0]);
                    write((Double) paramMissingValue.getValues()[1]);
                    write((Double) paramMissingValue.getValues()[2]);
                }
                break;
        }
    }

    private void checkVar(SPSSVariable paramSPSSVariable)
            throws IOException {
        if (this.vars.contains(paramSPSSVariable)) {
            throw new IOException("wrong data output (variable duplicate name " + paramSPSSVariable.getLongName() + ")");
        }
        for (int i = 0; containsShortName(paramSPSSVariable); i++) {
            String str = String.valueOf(i);
            paramSPSSVariable.setName(paramSPSSVariable.getName().substring(0, 8 - str.length()) + str);
        }
    }

    private boolean containsShortName(SPSSVariable paramSPSSVariable) {
        for (int i = 0; i < this.vars.size(); i++) {
            if (((SPSSVariable) this.vars.elementAt(i)).getName().equals(paramSPSSVariable.getName())) {
                return true;
            }
        }
        return false;
    }

    public void addDataSection()
            throws IOException {
        if (!this.dictionary) {
            throw new IOException("wrong data output (dictionary section has not been added)");
        }
        if (this.data) {
            throw new IOException("wrong data output (data section has been added already)");
        }
        if ((this.vars == null) || (this.vars.size() <= 0)) {
            throw new IOException("wrong data output (there is no variables defined)");
        }
        if (this.directDataWriting) {
            this.out = this.realOut;
            System.err.println("111");
        } else {
            this.out = this.dataBuffer;
            System.err.println("222");
        }
        byte[] arrayOfByte = this.headerBuffer.toByteArray();
        if (this.numberOfVars == -1) {
            arrayOfByte = modifyVarsCount(arrayOfByte);
        }
        out.write(arrayOfByte);
        this.out.flush();
        this.headerBuffer.reset();
        this.headerBuffer = null;
        addValueLabels();
        addCharCodeInfo();
        addStoreFormatInformation();
        addVariableLongNames();
        addLongStringsInfo();
        addEncodingInfo();
        writeExtVl();
        write(999L);
        this.out.flush();
        this.data = true;
        this.currentVar = 0;
        this.buffer = new SPSSBuffer(500);
    }

    private void addLongStringsInfo()
            throws IOException {
        if ((this.longStrings == null) || (this.longStrings.size() == 0)) {
            return;
        }
        write(7);
        write(14);
        write(1);
        String str = formatLongStrings();
        write(str.length());
        write(str);
    }

    private String formatLongStrings() {
        Iterator localIterator = this.longStrings.keySet().iterator();
        StringBuilder localStringBuilder = new StringBuilder();
        while (localIterator.hasNext()) {
            String str = (String) localIterator.next();
            formatLongString(str, ((Integer) this.longStrings.get(str)), localStringBuilder);
        }
        return localStringBuilder.toString();
    }

    private void formatLongString(String paramString, int paramInt, StringBuilder paramStringBuilder) {
        paramStringBuilder.append(paramString.trim()).append("=").append(paramInt).append("\000\t");
    }

    private void addCharCodeInfo()
            throws IOException {
        write(7);
        write(3);
        write(4);
        write(8);
        write(17);
        write(0);
        write(0);
        write(720);
        write(1);
        write(1);
        write(2);
        if ((this.charset == null) || (this.charset.length() == 0)) {
            write(1252);
            return;
        }
        if (this.charset.toLowerCase().contains("utf")) {
            write(65001);
        } else {
            write(1252);
        }
    }

    private void addEncodingInfo()
            throws IOException {
        write(7);
        write(20);
        write(1);
        String str;
        if ((this.charset == null) || (this.charset.length() == 0)) {
            str = System.getProperty("file.encoding");
        } else {
            str = this.charset;
        }
        byte[] arrayOfByte = convert(str);
        write(arrayOfByte.length);
        write(arrayOfByte);
    }

    private void addValueLabels()
            throws IOException {
        Vector localVector = new Vector();
        Iterator localIterator1 = this.valueLabels.keySet().iterator();
        while (localIterator1.hasNext()) {
            //mod Integer
            Object localObject = (Integer) localIterator1.next();
            localVector.add(localObject);
        }
        Collections.sort(localVector);
        Object localObject = localVector.iterator();
        this.complexVls = new Vector();
        this.complexVlsIndexes = new Vector();
        while (((Iterator) localObject).hasNext()) {
            Integer localInteger = (Integer) ((Iterator) localObject).next();
            ValueLabels localValueLabels = (ValueLabels) this.valueLabels.get(localInteger);
            if (!localValueLabels.isSimpleLabel()) {
                this.complexVls.add(localValueLabels);
                this.complexVlsIndexes.add(localInteger);
            } else {
                write(3);
                write(localValueLabels.getValueLabels().size());
                Iterator localIterator2 = localValueLabels.getValues().iterator();
                while (localIterator2.hasNext()) {
                    Double localDouble = (Double) localIterator2.next();
                    String str = (String) localValueLabels.getValueLabels().get(localDouble);
                    if (str.length() > 255) {
                        str = str.substring(0, 255);
                    }
                    write(localDouble.doubleValue());
                    byte[] arrayOfByte1 = null;
                    if (this.charset == null) {
                        arrayOfByte1 = str.getBytes();
                    } else {
                        arrayOfByte1 = str.getBytes(this.charset);
                    }
                    writeAsOneByte((byte) arrayOfByte1.length);
                    byte[] arrayOfByte2 = arrayOfByte1;
                    arrayOfByte1 = new byte[arrayOfByte1.length + 1];
                    for (int i = 0; i < arrayOfByte2.length; i++) {
                        arrayOfByte1[i] = arrayOfByte2[i];
                    }
                    arrayOfByte1[(arrayOfByte1.length - 1)] = 32;
                    arrayOfByte1 = getLabelFilledSpaces(arrayOfByte1);
                    arrayOfByte1 = substrb(arrayOfByte1, arrayOfByte1.length - 1);
                    write(arrayOfByte1);
                }
                write(4);
                write(1);
                write(getVarIndex(localInteger));
            }
        }
    }

    private void writeExtVl()
            throws IOException {
        if ((this.complexVls != null) && (!this.complexVls.isEmpty())) {
            write(7);
            write(21);
            ByteArrayOutputStream localByteArrayOutputStream = contructExtendedValueLabels(this.complexVlsIndexes, this.complexVls);
            write(1);
            int i = localByteArrayOutputStream.size();
            write(i);
            write(localByteArrayOutputStream.toByteArray());
        }
    }

    private ByteArrayOutputStream contructExtendedValueLabels(List paramList1, List paramList2)
            throws IOException {
        ByteArrayOutputStream localByteArrayOutputStream = new ByteArrayOutputStream();
        Iterator localIterator1 = paramList1.iterator();
        Iterator localIterator2 = paramList2.iterator();
        while ((localIterator1.hasNext()) && (localIterator2.hasNext())) {
            Integer localInteger = (Integer) localIterator1.next();
            ValueLabels localValueLabels = (ValueLabels) localIterator2.next();
            SPSSVariable localSPSSVariable = (SPSSVariable) this.vars.elementAt(localInteger - 1);
            String str1 = localSPSSVariable.getLongName();
            localByteArrayOutputStream.write(convert(str1.length()));
            localByteArrayOutputStream.write(convert(str1));
            localByteArrayOutputStream.write(convert(getWidth(localSPSSVariable)));
            localByteArrayOutputStream.write(convert(localValueLabels.values.size()));
            Iterator localIterator3 = localValueLabels.values.iterator();
            while (localIterator3.hasNext()) {
                Object localObject = localIterator3.next();
                String str2 = localObject.toString();
                String str3 = (String) localValueLabels.data.get(localObject);
                byte[] arrayOfByte = convert(str2);
                int i = getWidth(localSPSSVariable);
                localByteArrayOutputStream.write(convert(i));
                localByteArrayOutputStream.write(equalByteArrLength(arrayOfByte, i));
                localByteArrayOutputStream.write(convert(str3.length()));
                localByteArrayOutputStream.write(convert(str3));
            }
        }
        return localByteArrayOutputStream;
    }

    private int getWidth(SPSSVariable paramSPSSVariable) {
        if (longString(paramSPSSVariable)) {
            return ((Integer) this.longStrings.get(paramSPSSVariable.getName()));
        }
        return paramSPSSVariable.getWidth();
    }

    private byte[] convert(String paramString) {
        if (this.charset == null) {
            return paramString.getBytes();
        }
        try {
            return paramString.getBytes(this.charset);
        } catch (UnsupportedEncodingException localUnsupportedEncodingException) {
        }
        return paramString.getBytes();
    }

    private int getVarIndex(int paramInt)
            throws IOException {
        int i = 1;
        for (int j = 0; j < this.vars.size(); j++) {
            SPSSVariable localSPSSVariable = (SPSSVariable) this.vars.elementAt(j);
            if (j == paramInt - 1) {
                if (localSPSSVariable.getType() == 1) {
                    throw new IOException("wrong data output (ValueLabels:  Variable " + paramInt + " type cannot be String )");
                }
                return i;
            }
            switch (localSPSSVariable.getType()) {
                case 1:
                    if (localSPSSVariable.getWidth() > 255) {
                        localSPSSVariable.setWidth(255);
                    }
                    if (localSPSSVariable.getWidth() < 8) {
                        localSPSSVariable.setWidth(8);
                    }
                    i = (int) (i + Math.ceil(localSPSSVariable.getWidth() / 8.0D));
                    break;
                case 3:
                case 4:
                case 5:
                case 20:
                case 21:
                case 22:
                case 23:
                case 24:
                case 25:
                case 26:
                case 27:
                case 28:
                case 29:
                case 30:
                case 32:
                case 38:
                    i++;
                    break;
                case 2:
                case 6:
                case 7:
                case 8:
                case 9:
                case 10:
                case 11:
                case 12:
                case 13:
                case 14:
                case 15:
                case 16:
                case 17:
                case 18:
                case 19:
                case 31:
                case 33:
                case 34:
                case 35:
                case 36:
                case 37:
                default:
                    i = (int) (i + Math.ceil(localSPSSVariable.getWidth() / 8.0D));
            }
        }
        throw new IOException("wrong data output (ValueLabels:  Variable " + paramInt + " not found )");
    }

    private static byte[] getLabelFilledSpaces(byte[] paramArrayOfByte) {
        if (paramArrayOfByte.length % 8 == 0) {
            return paramArrayOfByte;
        }
        int i = 8 - (paramArrayOfByte.length < 8 ? paramArrayOfByte.length : paramArrayOfByte.length % 8);
        byte[] arrayOfByte = new byte[paramArrayOfByte.length + i];
        for (int j = 0; j < paramArrayOfByte.length + i; j++) {
            if (j < paramArrayOfByte.length) {
                arrayOfByte[j] = paramArrayOfByte[j];
            } else {
                arrayOfByte[j] = 32;
            }
        }
        return arrayOfByte;
    }

    /*public static void main(String[] paramArrayOfString) {
        System.out.println("12345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890".length());
        List localList = new SPSSWriterImpl().splitString("12345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890", 3, 515);
        System.out.println("'" + localList.get(0) + "', '" + localList.get(1) + "', '" + localList.get(2) + "';");
        System.out.println("" + ((String) localList.get(0)).length() + ", " + ((String) localList.get(1)).length() + ", " + ((String) localList.get(2)).length() + ";");
    }*/
    private void writeAsOneByte(byte paramByte)
            throws IOException {
        byte[] arrayOfByte = new byte[1];
        arrayOfByte[0] = paramByte;
        write(arrayOfByte);
    }

    private void addStoreFormatInformation()
            throws IOException {
        if (this.storeFormat) {
            int i = this.vars.size();
            write(FORMAT_SECTION);
            write(3 * i);
            for (int j = 0; j < i; j++) {
                SPSSVariable localSPSSVariable = (SPSSVariable) this.vars.elementAt(j);
                write(localSPSSVariable.getMeasure());
                write(localSPSSVariable.getColumns());
                write(localSPSSVariable.getAlign());
            }
        }
    }

    private byte[] modifyVarsCount(byte[] paramArrayOfByte) {
        int i = 0;
        for (int j = 0; j < this.vars.size(); j++) {
            SPSSVariable localSPSSVariable = (SPSSVariable) this.vars.elementAt(j);
            switch (localSPSSVariable.getType()) {
                case 1:
                    if (localSPSSVariable.getWidth() > 255) {
                        localSPSSVariable.setWidth(255);
                    }
                    if (localSPSSVariable.getWidth() < 8) {
                        localSPSSVariable.setWidth(8);
                    }
                    i = (int) (i + Math.ceil(localSPSSVariable.getWidth() / 8.0D));
                    break;
                default:
                    i = (int) (i + Math.ceil(localSPSSVariable.getWidth() / 8.0D));
            }
        }
        byte[] arrayOfByte = convert(i);
        System.arraycopy(arrayOfByte, 0, paramArrayOfByte, 68, arrayOfByte.length);
        return paramArrayOfByte;
    }

    private void addVariableLongNames()
            throws IOException {
        write(7);
        write(13);
        write(1);
        String str = getValueLongNamesString();
        byte[] arrayOfByte = null;
        if (this.charset != null) {
            arrayOfByte = str.getBytes(this.charset);
        } else {
            arrayOfByte = str.getBytes();
        }
        write(arrayOfByte.length);
        write(arrayOfByte);
    }

    private String getValueLongNamesString() {
        StringBuffer localStringBuffer = new StringBuffer();
        for (int i = 0; i < this.vars.size(); i++) {
            SPSSVariable localSPSSVariable = (SPSSVariable) this.vars.elementAt(i);
            String str = localSPSSVariable.getName();
            str = str.toUpperCase().trim();
            if (!localSPSSVariable.isFake()) {
                localStringBuffer.append(str);
                localStringBuffer.append("=");
                localStringBuffer.append(localSPSSVariable.getLongName());
                localStringBuffer.append('\t');
            }
        }
        return localStringBuffer.substring(0, localStringBuffer.length() - 1);
    }

    private byte[] modifyRowsCount(byte[] paramArrayOfByte) {
        byte[] arrayOfByte = convert(this.rowCount);
        System.arraycopy(arrayOfByte, 0, paramArrayOfByte, 80, arrayOfByte.length);
        return paramArrayOfByte;
    }

    public void addData(Long paramLong)
            throws IOException {
        if (paramLong == null) {
            addData((Double) null);
        } else {
            addData(paramLong.doubleValue());
        }
    }

    public void addData(Double paramDouble)
            throws IOException {
        addAllData(paramDouble);
    }

    public void addData(String paramString)
            throws IOException {
        addAllData(paramString);
    }

    public void addData(Date paramDate)
            throws IOException {
        addAllData(paramDate);
    }

    private void addAllData(Object paramObject)
            throws IOException {
        if (!this.dictionary) {
            throw new IOException("wrong data output (dictionary section has not been added)");
        }
        if (!this.data) {
            throw new IOException("wrong data output (data section has not been added)");
        }
        if ((this.vars == null) || (this.vars.size() <= 0)) {
            throw new IOException("wrong data output (there is no variables defined)");
        }
        if ((ISettings.IS_LIBRARY_DEMO) && (this.currentVar == 0)) {
            addAllDataRaw(getDemoVersionLabel());
        }
        addAllDataRaw(paramObject);
    }

    private void addAllDataRaw(Object paramObject)
            throws IOException {
        SPSSVariable localSPSSVariable = (SPSSVariable) this.vars.elementAt(this.currentVar);
        if ((paramObject == null) && (localSPSSVariable.getType() == 1)) {
            paramObject = "";
        }
        try {
            int k;
            if (paramObject == null) {
                switch (localSPSSVariable.getType()) {
                    case 1:
                        int i = localSPSSVariable.getWidth();
                        if (longString(localSPSSVariable)) {
                            k = countStrings(i) - 1;
                            i = ((Integer) this.longStrings.get(localSPSSVariable.getName())) + k * 3;
                            this.currentVar += countStrings(i) - 1;
                        }
                        k = i % 8 == 0 ? i : (i / 8 + 1) * 8;
                        int m = k / 8;
                        byte[] arrayOfByte = new byte[m];
                        Arrays.fill(arrayOfByte, (byte) -2);
                        this.buffer.addCompressed(arrayOfByte);
                        break;
                    default:
                        this.buffer.addCompressed((byte) -1);
                }
            } else if ((paramObject instanceof Long)) {
                switch (localSPSSVariable.getType()) {
                    case 3:
                    case 4:
                    case 5:
                    case 32:
                        long l = ((Long) paramObject);
                        if ((l >= 1L) && (l <= 251L)) {
                            this.buffer.addCompressed((byte) (int) l);
                        } else {
                            this.buffer.addCompressed((byte) -3);
                            this.buffer.addData(convert(l));
                        }
                        break;
                    default:
                        throw new IOException("wrong data output (data format mismatch)");
                }
            } else if ((paramObject instanceof Double)) {
                switch (localSPSSVariable.getType()) {
                    case 3:
                    case 4:
                    case 5:
                    case 32:
                        double d1 = ((Double) paramObject);
                        this.buffer.addCompressed((byte) -3);
                        this.buffer.addData(convert(d1));
                        break;
                    default:
                        throw new IOException("wrong data output (data format mismatch)");
                }
            } else if ((paramObject instanceof String)) {
                switch (localSPSSVariable.getType()) {
                    case 1:
                        String str = (String) paramObject;
                        if (longString(localSPSSVariable)) {
                            k = ((Integer) this.longStrings.get(localSPSSVariable.getName()));
                            List localList = splitString(str, countStrings(k), k);
                            for (int n = 0; n < localList.size() - 1; n++) {
                                rawWriteString((SPSSVariable) this.vars.get(this.currentVar++), (String) localList.get(n), 255);
                                k -= 255;
                            }
                            rawWriteString((SPSSVariable) this.vars.get(this.currentVar), (String) localList.get(localList.size() - 1), k);
                        } else {
                            rawWriteString(localSPSSVariable, str, localSPSSVariable.getWidth());
                        }
                        break;
                    default:
                        throw new IOException("wrong data output (data format mismatch)");
                }
            } else if ((paramObject instanceof Date)) {
                int j = localSPSSVariable.getType() << 16 | localSPSSVariable.getWidth() << 8 | localSPSSVariable.getDecimals();
                switch (j) {
                    case 1313024:
                    case 1313536:
                    case 1377536:
                    case 1378304:
                    case 1379074:
                    case 1446144:
                    case 1446912:
                    case 1447682:
                    case 1509376:
                    case 1509888:
                    case 1574144:
                    case 1574656:
                    case 1640704:
                    case 1641472:
                    case 1642242:
                    case 1704704:
                    case 1706240:
                    case 1770240:
                    case 1771776:
                    case 1836544:
                    case 1837056:
                    case 1902080:
                    case 1902592:
                    case 1968128:
                    case 1968640:
                    case 2492160:
                    case 2492928:
                        double d2 = dateToSpssDouble((Date) paramObject);
                        this.buffer.addCompressed((byte) -3);
                        this.buffer.addData(convert(d2));
                        break;
                    default:
                        throw new IOException("wrong data output (data format mismatch)");
                }
            } else {
                throw new IOException("wrong data output (data format mismatch)");
            }
            this.currentVar += 1;
            if (this.currentVar >= this.vars.size()) {
                this.currentVar = 0;
                this.rowCount += 1;
            }
            this.buffer.flushBuffer(this.out);
        } catch (BufferOverflowException localBufferOverflowException) {
            localBufferOverflowException.printStackTrace();
            this.buffer.flushBuffer(this.out);
        }
    }

    private List splitString(String paramString, int paramInt1, int paramInt2) {
        ArrayList localArrayList = new ArrayList();
        int i = 0;
        while ((paramString.length() > 0) && (localArrayList.size() < paramInt1)) {
            int j = Math.min(255, Math.min(paramInt2 - i, paramString.length()));
            localArrayList.add(paramString.substring(0, j));
            if (j <= paramString.length()) {
                paramString = paramString.substring(j);
            }
            i += j;
        }
        while (localArrayList.size() < paramInt1) {
            localArrayList.add("");
        }
        return localArrayList;
    }

    private void rawWriteString(SPSSVariable paramSPSSVariable, String paramString, int paramInt)
            throws UnsupportedEncodingException, BufferOverflowException {
        byte[] arrayOfByte1 = null;
        if (this.charset != null) {
            arrayOfByte1 = paramString.getBytes(this.charset);
        } else {
            arrayOfByte1 = paramString.getBytes();
        }
        int i = paramSPSSVariable.getWidth();
        int j = i % 8 == 0 ? i : (i / 8 + 1) * 8;
        int k = j / 8;
        byte[] arrayOfByte2 = new byte[k];
        if (paramString.length() <= 0) {
            Arrays.fill(arrayOfByte2, (byte) -2);
            this.buffer.addCompressed(arrayOfByte2);
        } else {
            if (arrayOfByte1.length > i) {
                arrayOfByte1 = substrb(arrayOfByte1, i);
            }
            int m = arrayOfByte1.length;
            if (m % 8 != 0) {
                m = (m / 8 + 1) * 8;
                arrayOfByte1 = equalByteArrLength(arrayOfByte1, m);
            }
            for (int n = 0; n < k; n++) {
                if (n < m / 8) {
                    arrayOfByte2[n] = -3;
                } else {
                    arrayOfByte2[n] = -2;
                }
            }
            this.buffer.addCompressed(arrayOfByte2);
            this.buffer.addData(arrayOfByte1);
        }
    }

    private boolean longString(SPSSVariable paramSPSSVariable) {
        return this.longStrings.containsKey(paramSPSSVariable.getName());
    }

    private double dateToSpssDouble(Date paramDate) {
        long l1 = paramDate.getTime();
        long l2 = 12219379200L;
        return l1 / 1000L + l2;
    }

    private byte[] equalByteArrLength(byte[] paramArrayOfByte, int paramInt) {
        int i;
        byte[] arrayOfByte = new byte[paramInt];
        if (paramArrayOfByte.length > paramInt) {
            return substrb(paramArrayOfByte, paramInt);
        }
        if (paramArrayOfByte.length == paramInt) {
            return paramArrayOfByte;
        }
        for (i = 0; i < paramArrayOfByte.length; i++) {
            arrayOfByte[i] = paramArrayOfByte[i];
        }
        //mod i

        while (i < paramInt) {
            arrayOfByte[i] = 32;
            i++;
        }
        return arrayOfByte;
    }

    private byte[] substrb(byte[] paramArrayOfByte, int paramInt) {
        byte[] arrayOfByte = new byte[paramInt];
        for (int i = 0; i < arrayOfByte.length; i++) {
            arrayOfByte[i] = paramArrayOfByte[i];
        }
        return arrayOfByte;
    }

    public void finishCurrentLine()
            throws IOException {
        do {
            addAllData(null);
        } while (this.currentVar != 0);
    }

    private String getDemoVersionLabel() {
        StringBuffer localStringBuffer = new StringBuffer();
        String str = null;
        addChar(localStringBuffer, 68);
        addChar(localStringBuffer, 101);
        addChar(localStringBuffer, 109);
        addChar(localStringBuffer, 111);
        addChar(localStringBuffer, 86);
        addChar(localStringBuffer, 101);
        addChar(localStringBuffer, 114);
        addChar(localStringBuffer, 115);
        str = "US";
        addChar(localStringBuffer, 105);
        addChar(localStringBuffer, 111);
        addChar(localStringBuffer, 110);
        str.substring(1, 1);
        return localStringBuffer.toString();
    }

    private void addChar(StringBuffer paramStringBuffer, int paramInt) {
        int i = 0;
        for (i = 0; i < paramInt; i++) {
        }
        char c = (char) i;
        paramStringBuffer.append(c);
    }

    public void addFinishSection()
            throws IOException {
        if (!this.dictionary) {
            throw new IOException("wrong data output (dictionary section has not been added)");
        }
        if (!this.data) {
            throw new IOException("wrong data output (data section has not been added)");
        }
        if (!this.directDataWriting) {
            this.out = this.realOut;
            this.out.write(modifyRowsCount(this.dataBuffer.toByteArray()));
            this.out.flush();
            this.dataBuffer.reset();
            this.dataBuffer = null;
        }
        try {
            this.buffer.addCompressed((byte) -4);
            while (this.buffer.getLength() % 8 != 0) {
                this.buffer.addCompressed((byte) 0);
            }
            this.buffer.flushBuffer(this.out);
            this.dictionary = false;
            this.data = false;
        } catch (BufferOverflowException localBufferOverflowException) {
            localBufferOverflowException.printStackTrace();
            this.buffer.flushBuffer(this.out);
        } finally {
            if (this.closeOutputStream) {
                realOut.close();
                out.close();
            }
        }
    }

    private void write(String paramString)
            throws IOException {
        if (this.charset != null) {
            this.out.write(paramString.getBytes(this.charset));
        } else {
            this.out.write(paramString.getBytes());
        }
    }

    private void write(byte[] paramArrayOfByte)
            throws IOException {
        this.out.write(paramArrayOfByte);
    }

    private void write(int paramInt)
            throws IOException {
        this.out.write(convert(paramInt));
    }

    private void write(long paramLong)
            throws IOException {
        this.out.write(convert(paramLong));
    }

    private void write(float paramFloat)
            throws IOException {
        write(Float.floatToIntBits(paramFloat));
    }

    private void write(double paramDouble)
            throws IOException {
        write(Double.doubleToLongBits(paramDouble));
    }

    private void write(Double paramDouble)
            throws IOException {
        write(Double.doubleToLongBits(paramDouble));
    }

    private byte[] convert(int paramInt) {
        byte[] arrayOfByte = new byte[4];
        for (int i = 0; i < arrayOfByte.length; i++) {
            arrayOfByte[i] = ((byte) paramInt);
            paramInt >>= 8;
        }
        return arrayOfByte;
    }

    private byte[] convert(long paramLong) {
        byte[] arrayOfByte = new byte[8];
        for (int i = 0; i < arrayOfByte.length; i++) {
            arrayOfByte[i] = ((byte) (int) paramLong);
            paramLong >>= 8;
        }
        return arrayOfByte;
    }

    private byte[] convert(float paramFloat) {
        return convert(Float.floatToIntBits(paramFloat));
    }

    private byte[] convert(double paramDouble) {
        return convert(Double.doubleToLongBits(paramDouble));
    }

    public void addValueLabels(int paramInt, ValueLabels paramValueLabels)
            throws IOException {
        if (!this.dictionary) {
            throw new IOException("wrong data output (dictionary section has not been added)");
        }
        if (this.data) {
            throw new IOException("wrong data output (data section has been added already)");
        }
        int i = paramInt + (ISettings.IS_LIBRARY_DEMO ? 1 : 0);
        int j = 0;
        for (int k = 0; k < i - 1; k++) {
            if (this.shift.containsKey(k)) {
                j += ((Integer) this.shift.get(k)) - 1;
            }
        }
        this.valueLabels.put(i + j, paramValueLabels);
    }
//</editor-fold>   

}
